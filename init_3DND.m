function init_3DND(HiC, bin_index, gene_index, outfile)
% init_3DND(infile)
% generate 3D Network Distances (3DND) in gene coordinates from Hi-C maps.
%
% INPUT:
% [HiC]: NxN symmetric matrix of Hi-C frequencies between bins, after bias-correction
% [bin_index]: Nx3 array, each row containing the chromosome, start and end
%       coordinates of the i-th bin.
% [gene_index]: Mx3 array, each row containing the chromosome, start and
%       end coordinates of the i-th gene.
% [outfile]: path to file.
%
% OUTPUT: (written to [outfile])
% [D]: MxM matrix of 3DND in gene coordinates.
% [gene_index]: see above.
%
% Alon Diament, Tuller Lab

%% Hi-C GRAPH
% frequencies to probabilities
% normalize the Hi-C map for sum-of-rows/cols == 1

fprintf('\nfreq to prob\n');
n_loci = size( bin_index, 1);
HiC = HiC - diag( diag( HiC)); % zero diagonal
HiC(HiC == 0) = NaN;  % missing values
for itr = 1:20
    HiC = HiC ./ repmat( nansum( HiC,1), n_loci,1); % normalize cols
    HiC = HiC ./ repmat( nansum( HiC,2), 1,n_loci); % normalize rows
end
HiC = (HiC + HiC') / 2;  % enforce symmetry
HiC(HiC >= 1) = 1 - 1e-6;  % no zeros (treated as missing values) in log-map

HiC = -log(HiC);
HiC(isnan(HiC)) = 0;  % place back missing values

%% SHORTEST PATHS

fprintf('all-pairs shortest distance...')
HiC = sparse( tril( HiC));
D = single( graphallshortestpaths( HiC, 'Directed', false));
D( isinf(D)) = 0;  % missing
fprintf('OK\n');

%% TRANSFORM TO GENE COORDINATES

fprintf('bins to genes\n');
node_map = map_bilinear(gene_index, bin_index);
D = single(apply_bilinear(node_map, D));

save(outfile, 'D', 'gene_index');
fprintf('saved %s\n', outfile);
end


function M = map_bilinear(target, source)
% M = mapSmooth(target, from)
%   mapping from [source] coordinates to [target] coordinates using
%   linear iterpolation/smoothing. transformation [M] should be used so:
%   T = M * S * M' ./ (M * (S~=0) * M')
%   to account for missing values (zeros). can use apply_bilinear().
%
% Alon Diament, Tuller Lab.

% mid-points:
target(:, 4) = 0.5*(target(:, 2) + target(:, 3));
source(:, 4) = 0.5*(source(:, 2) + source(:, 3));

N = size(target, 1);
M = spalloc(N, size(source, 1), 2*N);

for i = 1:N % every target
    
    % closest segment (measuring from mid-point to mid-point)
    [~, ind] = min( abs( source(:, 4) - target(i, 4)) ...
        + 1e12*( source(:, 1) ~= target(i, 1)));
    % the above statement gives very high penalty (1e12) for coordinates
    % from different chromosomes, so that won't happen.

    if (source(ind, 4) - target(i, 4)) > 0 && (ind > 1)
        % ensuring target is between the two chosen bins
        ind = ind - 1;
    end
    if ind == size(source, 1)
        % end of genome case
        ind = ind - 1;
    elseif source(ind+1, 1) ~= source(ind, 1)
        % end of chromosome case
        ind = ind - 1;
    end

    M(i, ind+1) = (target(i, 4) - source(ind, 4)) ...
        / (source(ind+1, 4) - source(ind, 4));
    M(i, ind) = 1 - M(i, ind+1);
end
end


function T = apply_bilinear(M, S)
% T = apply_bilinear(M, S)
% map using [M] (generated by map_bilinear()) from source [S] to target [T].
%
% Alon Diament, Tuller Lab.

min_allowed = 0;
max_allowed = 1.1*max(S(:));

T = M * double(S) * M' ./ ...
    (M * (double(S)~=0) * M');  % normalizing sum of weights to 1
T = full(T);

% cleanup
T(isnan(T)) = 0;
T(T < min_allowed) = min_allowed;  % if extrapolating values
T(T > max_allowed) = max_allowed;
N = size(T, 1);
T(1:N+1:N^2) = 0;  % diagonal
end
